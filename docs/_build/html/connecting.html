

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Connecting to RabbitMQ &mdash; Pika 0.9a documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.9a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Pika 0.9a documentation" href="index.html" />
    <link rel="next" title="Communicating with RabbitMQ" href="communicating.html" />
    <link rel="prev" title="Introduction to Pika" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="communicating.html" title="Communicating with RabbitMQ"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Introduction to Pika"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Pika 0.9a documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="connecting-to-rabbitmq">
<h1>Connecting to RabbitMQ<a class="headerlink" href="#connecting-to-rabbitmq" title="Permalink to this headline">¶</a></h1>
<p>Pika provides multiple adapters to connect to RabbitMQ allowing for different ways of providing socket communication depending on what is appropriate for your application.</p>
<ul class="simple">
<li><a class="reference internal" href="#adapters-select-connection-selectconnection"><em>SelectConnection</em></a>: A native event based connection adapter that implements select, kqueue, poll and epoll.</li>
<li><a class="reference internal" href="#adapters-asyncore-connection-asyncoreconnection"><em>AsyncoreConnection</em></a>: Legacy adapter kept for convenience of previous Pika users.</li>
<li><a class="reference internal" href="#adapters-tornado-connection-tornadoconnection"><em>TornadoConnection</em></a>: Connection adapter for use with the Tornado IO Loop.</li>
<li><a class="reference internal" href="#adapters-blocking-connection-blockingconnection"><em>BlockingConnection</em></a>: Enables blocking, synchronous operation on top of library for simple uses.</li>
</ul>
<div class="section" id="io-and-event-looping">
<span id="intro-to-ioloop"></span><h2>IO and Event Looping<a class="headerlink" href="#io-and-event-looping" title="Permalink to this headline">¶</a></h2>
<p>Due to the need to check for and send content on a consistent basis, Pika now implements or extends IOLoops in each of its asynchronous connection adapters. These IOLoops are blocking methods which loop and listen for events. Each asynchronous adapters follows the same standard for invoking the IOLoop. The IOLoop is
created when the connection adapter is created. To start it simply call the connection.ioloop.start() method.</p>
<p>If you are using an external IOLoop such as Tornado&#8217;s IOLoop, you may invoke that as you normally would and then add the adapter to it.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pika.adapters</span> <span class="kn">import</span> <span class="n">SelectConnection</span>

<span class="c"># Create our connection object</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">SelectConnection</span><span class="p">()</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c"># Loop so we can communicate with RabbitMQ</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">ioloop</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
    <span class="c"># Gracefully close the connection</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="c"># Loop until we&#39;re fully closed, will stop on its own</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">ioloop</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="continuation-passing-style">
<span id="intro-to-cps"></span><h2>Continuation-Passing Style<a class="headerlink" href="#continuation-passing-style" title="Permalink to this headline">¶</a></h2>
<p>Interfacing with Pika asynchronously is done by passing in callback methods you would like to have invoked when a certain event has completed. For example, if you are going to declare a queue, you pass in a method that will be called when the RabbitMQ server returns a <a class="reference external" href="http://www.rabbitmq.com/amqp-0-9-1-quickref.html#queue.declare">Queue.DeclareOk</a> response.</p>
<p>In our example below we use the following four easy steps:</p>
<ol class="arabic simple">
<li>We start by creating our connection object, then starting our event loop.</li>
<li>When we are connected, the <em>on_connected</em> method is called. In that method we create a channel.</li>
<li>When the channel is created, the <em>on_channel_open</em> method is called. In that method we declare a queue.</li>
<li>When the queue is declared successfully, <em>on_queue_declared</em> is called. In that method we call <a class="reference internal" href="communicating.html#channel.Channel.basic_consume" title="channel.Channel.basic_consume"><tt class="xref py py-meth docutils literal"><span class="pre">channel.basic_consume</span></tt></a> telling it to call the handle_delivery for each message RabbitMQ delivers to us.</li>
<li>When RabbitMQ has a message to send us, it call the handle_delivery method passing the AMQP Method frame, Header frame and Body.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Step #1 is on line #28 and Step #2 is on line #6. This is so that Python knows about the functions we&#8217;ll call in Steps #2 through #5.</p>
</div>
<p id="cps-example">Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pika.adapters</span> <span class="kn">import</span> <span class="n">SelectConnection</span>

<span class="c"># Create a global channel variable to hold our channel object in</span>
<span class="n">channel</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c"># Step #2</span>
<span class="k">def</span> <span class="nf">on_connected</span><span class="p">(</span><span class="n">connection</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Called when we are fully connected to RabbitMQ&quot;&quot;&quot;</span>
    <span class="c"># Open a channel</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">channel</span><span class="p">(</span><span class="n">on_channel_open</span><span class="p">)</span>

<span class="c"># Step #3</span>
<span class="k">def</span> <span class="nf">on_channel_open</span><span class="p">(</span><span class="n">new_channel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Called when our channel has opened&quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">channel</span>
    <span class="n">channel</span> <span class="o">=</span> <span class="n">new_channel</span>
    <span class="n">channel</span><span class="o">.</span><span class="n">queue_declare</span><span class="p">(</span><span class="n">queue</span><span class="o">=</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="n">durable</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">auto_delete</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">on_queue_declared</span><span class="p">)</span>

<span class="c"># Step #4</span>
<span class="k">def</span> <span class="nf">on_queue_declared</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Called when RabbitMQ has told us our Queue has been declared, frame is the response from RabbitMQ&quot;&quot;&quot;</span>
    <span class="n">channel</span><span class="o">.</span><span class="n">basic_consume</span><span class="p">(</span><span class="n">handle_delivery</span><span class="p">,</span> <span class="n">queue</span><span class="o">=</span><span class="s">&#39;test&#39;</span><span class="p">)</span>

<span class="c"># Step #5</span>
<span class="k">def</span> <span class="nf">handle_delivery</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Called when we receive a message from RabbitMQ&quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="n">body</span>

<span class="c"># Step #1: Connect to RabbitMQ</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">SelectConnection</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">on_connected</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c"># Loop so we can communicate with RabbitMQ</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">ioloop</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
    <span class="c"># Gracefully close the connection</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="c"># Loop until we&#39;re fully closed, will stop on its own</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">ioloop</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="credentials">
<h2>Credentials<a class="headerlink" href="#credentials" title="Permalink to this headline">¶</a></h2>
<p>The credentials module provides the mechanism by which you pass the username
and password to the <a class="reference internal" href="#connection.ConnectionParameters" title="connection.ConnectionParameters"><tt class="xref py py-meth docutils literal"><span class="pre">connection.ConnectionParameters()</span></tt></a> class when it
is created.</p>
<span class="target" id="module-credentials"></span><dl class="class">
<dt id="credentials.PlainCredentials">
<em class="property">class </em><tt class="descclassname">credentials.</tt><tt class="descname">PlainCredentials</tt><big>(</big><em>username</em>, <em>password</em><big>)</big><a class="headerlink" href="#credentials.PlainCredentials" title="Permalink to this definition">¶</a></dt>
<dd><p>The PlainCredentials class returns the properly formatted username and
password to the Connection. As of this version of Pika, only
PlainCredentials are supported. To authenticate with Pika, simply create a
credentials object passing in the username and password and pass that to
the ConnectionParameters object.</p>
<p>If you do not pass in credentials to the ConnectionParameters object, it
will create credentials for &#8216;guest&#8217; with the password of &#8216;guest&#8217;.</p>
<p>Parameters:</p>
<ul class="simple">
<li>username: plain text string value</li>
<li>password: plain text string value</li>
</ul>
</dd></dl>

<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pika</span>
<span class="n">credentials</span> <span class="o">=</span> <span class="n">pika</span><span class="o">.</span><span class="n">PlainCredentials</span><span class="p">(</span><span class="s">&#39;username&#39;</span><span class="p">,</span> <span class="s">&#39;password&#39;</span><span class="p">)</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="n">pika</span><span class="o">.</span><span class="n">ConnectionParameters</span><span class="p">(</span><span class="n">credentials</span><span class="o">=</span><span class="n">credentials</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="connection-parameters">
<h2>Connection Parameters<a class="headerlink" href="#connection-parameters" title="Permalink to this headline">¶</a></h2>
<p>To connect to RabbitMQ via an adapter, first you must construct a ConnectionParameters
object. This has all of the options which are involved in creating a connection with
RabbitMQ.</p>
<span class="target" id="module-connection"></span><dl class="class">
<dt id="connection.ConnectionParameters">
<em class="property">class </em><tt class="descclassname">connection.</tt><tt class="descname">ConnectionParameters</tt><big>(</big><em>host='localhost'</em>, <em>port=5672</em>, <em>virtual_host='/'</em>, <em>credentials=None</em>, <em>channel_max=0</em>, <em>frame_max=131072</em>, <em>heartbeat=0</em><big>)</big><a class="headerlink" href="#connection.ConnectionParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Connection parameters object that is passed into the connection adapter
upon construction. The following parameters are passed and are used to
negotiate communication with RabbitMQ:</p>
<ul class="simple">
<li>host: Hostname or IP Address to connect to, defaults to localhost.</li>
<li>port: TCP port to connect to, defaults to 5672</li>
<li>virtual_host: RabbitMQ virtual host to use, defaults to /</li>
<li>credentials: A instance of a credentials class to authenticate with.
Defaults to PlainCredentials for the guest user.</li>
<li>channel_max: Maximum number of channels to allow, defaults to 0 for None</li>
<li>frame_max: The maximum byte size for an AMQP frame. Defaults to 131072</li>
<li>heartbeat: Turn heartbeat checking on or off. Defaults to 0 for Off.</li>
</ul>
</dd></dl>

<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pika</span>
<span class="n">credentials</span> <span class="o">=</span> <span class="n">pika</span><span class="o">.</span><span class="n">PlainCredentials</span><span class="p">(</span><span class="s">&#39;username&#39;</span><span class="p">,</span> <span class="s">&#39;password&#39;</span><span class="p">)</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="n">pika</span><span class="o">.</span><span class="n">ConnectionParameters</span><span class="p">(</span><span class="n">credentials</span><span class="o">=</span><span class="n">credentials</span><span class="p">,</span>
                                       <span class="n">host</span><span class="o">=</span><span class="s">&#39;rabbit-server1&#39;</span><span class="p">,</span>
                                       <span class="n">virtual_host</span><span class="o">=</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="tcp-backpressure">
<span id="intro-to-backpressure"></span><h2>TCP Backpressure<a class="headerlink" href="#tcp-backpressure" title="Permalink to this headline">¶</a></h2>
<p>As of RabbitMQ 2.0, client side <a class="reference external" href="http://www.rabbitmq.com/amqp-0-9-1-quickref.html#channel.flow">Channel.Flow</a> has been removed <a class="footnote-reference" href="#f1" id="id1">[1]</a>. Instead, the RabbitMQ
broker uses TCP Backpressure to slow your client if it is delivering messages too fast. Pika attempts to help you handle this situation by providing a
mechanism by which you may be notified if Pika has noticed too many frames have yet to be delivered. By registering a function with the
<a class="reference internal" href="#adapters.select_connection.SelectConnection.add_backpressure_callback" title="adapters.select_connection.SelectConnection.add_backpressure_callback"><tt class="xref py py-meth docutils literal"><span class="pre">add_backpressure_callback</span></tt></a> function of any connection adapter, your function will be called
when Pika sees that a backlog of 10 times the average frame size you have been sending has been exceeded. You may tweak this value by calling the
<a class="reference internal" href="#adapters.select_connection.SelectConnection.set_backpressure_multiplier" title="adapters.select_connection.SelectConnection.set_backpressure_multiplier"><tt class="xref py py-meth docutils literal"><span class="pre">set_backpressure_multiplier</span></tt></a> method passing any integer value.</p>
</div>
<div class="section" id="available-adapters">
<h2>Available Adapters<a class="headerlink" href="#available-adapters" title="Permalink to this headline">¶</a></h2>
<p>The following connection adapters are available for connecting with RabbitMQ:</p>
<div class="section" id="selectconnection">
<span id="adapters-select-connection-selectconnection"></span><h3>SelectConnection<a class="headerlink" href="#selectconnection" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">SelectConnection is the recommended method for using Pika under most circumstances. It supports multiple event notification methods including select, epoll, kqueue and poll.</p>
</div>
<p>By default SelectConnection will attempt to use the most appropriate event
notification method for your system. In order to override the default behavior
you may set the poller type by assigning a string value to the
select_connection modules POLLER_TYPE attribute prior to creating the
SelectConnection object instance. Valid values are: kqueue, poll, epoll, select</p>
<p>Poller Type Override Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">select_connection</span>
<span class="n">select_connection</span><span class="o">.</span><span class="n">POLLER_TYPE</span> <span class="o">=</span> <span class="s">&#39;epoll&#39;</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">select_connection</span><span class="o">.</span><span class="n">SelectConnection</span><span class="p">()</span>
</pre></div>
</div>
<p>See the <a class="reference internal" href="#cps-example"><em>Continuation-Passing Style example</em></a> for an example of using SelectConnection.</p>
<span class="target" id="module-adapters.select_connection"></span><dl class="class">
<dt id="adapters.select_connection.SelectConnection">
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">SelectConnection</tt><big>(</big><em>parameters=None</em>, <em>on_open_callback=None</em>, <em>reconnection_strategy=None</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="adapters.select_connection.SelectConnection.add_backpressure_callback">
<tt class="descname">add_backpressure_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection.add_backpressure_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when we think backpressue is being applied
due to the size of the output buffer being exceeded.</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectConnection.add_on_close_callback">
<tt class="descname">add_on_close_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection.add_on_close_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectConnection.add_on_open_callback">
<tt class="descname">add_on_open_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection.add_on_open_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has opened</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectConnection.channel">
<tt class="descname">channel</tt><big>(</big><em>on_open_callback</em>, <em>channel_number=None</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection.channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new channel with the next available channel number or pass in
a channel number to use. Must be non-zero if you would like to specify
but it is recommended that you let Pika manage the channel numbers.</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectConnection.close">
<tt class="descname">close</tt><big>(</big><em>code=200</em>, <em>text='Normal shutdown'</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnect from RabbitMQ. If there are any open channels, it will
attempt to close them prior to fully disconnecting. Channels which
have active consumers will attempt to send a Basic.Cancel to RabbitMQ
to cleanly stop the delivery of messages prior to closing the channel.</p>
</dd></dl>

<dl class="attribute">
<dt id="adapters.select_connection.SelectConnection.is_open">
<tt class="descname">is_open</tt><a class="headerlink" href="#adapters.select_connection.SelectConnection.is_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean reporting the current connection state</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectConnection.set_backpressure_multiplier">
<tt class="descname">set_backpressure_multiplier</tt><big>(</big><em>value=10</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectConnection.set_backpressure_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter the backpressure multiplier value. We set this to 10 by default.
This value is used to raise warnings and trigger the backpressure
callback.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="asyncoreconnection">
<span id="adapters-asyncore-connection-asyncoreconnection"></span><h3>AsyncoreConnection<a class="headerlink" href="#asyncoreconnection" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Use It is recommended that you use SelectConnection and its method signatures are the same as AsyncoreConnection.</p>
</div>
<p>The AsyncoreConnection class is provided for legacy support and quicker porting from applications that used Pika version 0.5.2 and prior.</p>
<span class="target" id="module-adapters.asyncore_connection"></span><dl class="class">
<dt id="adapters.asyncore_connection.AsyncoreConnection">
<em class="property">class </em><tt class="descclassname">adapters.asyncore_connection.</tt><tt class="descname">AsyncoreConnection</tt><big>(</big><em>parameters=None</em>, <em>on_open_callback=None</em>, <em>reconnection_strategy=None</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="adapters.asyncore_connection.AsyncoreConnection.add_backpressure_callback">
<tt class="descname">add_backpressure_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.add_backpressure_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when we think backpressue is being applied
due to the size of the output buffer being exceeded.</p>
</dd></dl>

<dl class="method">
<dt id="adapters.asyncore_connection.AsyncoreConnection.add_on_close_callback">
<tt class="descname">add_on_close_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.add_on_close_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.asyncore_connection.AsyncoreConnection.add_on_open_callback">
<tt class="descname">add_on_open_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.add_on_open_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has opened</p>
</dd></dl>

<dl class="method">
<dt id="adapters.asyncore_connection.AsyncoreConnection.channel">
<tt class="descname">channel</tt><big>(</big><em>on_open_callback</em>, <em>channel_number=None</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new channel with the next available channel number or pass in
a channel number to use. Must be non-zero if you would like to specify
but it is recommended that you let Pika manage the channel numbers.</p>
</dd></dl>

<dl class="method">
<dt id="adapters.asyncore_connection.AsyncoreConnection.close">
<tt class="descname">close</tt><big>(</big><em>code=200</em>, <em>text='Normal shutdown'</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnect from RabbitMQ. If there are any open channels, it will
attempt to close them prior to fully disconnecting. Channels which
have active consumers will attempt to send a Basic.Cancel to RabbitMQ
to cleanly stop the delivery of messages prior to closing the channel.</p>
</dd></dl>

<dl class="attribute">
<dt id="adapters.asyncore_connection.AsyncoreConnection.is_open">
<tt class="descname">is_open</tt><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.is_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean reporting the current connection state</p>
</dd></dl>

<dl class="method">
<dt id="adapters.asyncore_connection.AsyncoreConnection.set_backpressure_multiplier">
<tt class="descname">set_backpressure_multiplier</tt><big>(</big><em>value=10</em><big>)</big><a class="headerlink" href="#adapters.asyncore_connection.AsyncoreConnection.set_backpressure_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter the backpressure multiplier value. We set this to 10 by default.
This value is used to raise warnings and trigger the backpressure
callback.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="tornadoconnection">
<span id="adapters-tornado-connection-tornadoconnection"></span><h3>TornadoConnection<a class="headerlink" href="#tornadoconnection" title="Permalink to this headline">¶</a></h3>
<p>Tornado is an open source version of the scalable, non-blocking web server and tools that power FriendFeed. For more information on tornado, visit <a class="reference external" href="http://tornadoweb.org">http://tornadoweb.org</a></p>
<p>Since the Tornado IOLoop blocks once it is started, it is suggested that you use a timer to add Pika to your tornado.Application instance after the HTTPServer has started.</p>
<p>The following is a simple, non-working example on how to add Pika to the Tornado IOLoop without blocking other applications from doing so. To see a fully workng example,
see the Tornado Demo application in the examples.</p>
<p>Example:</p>
<div class="highlight-python"><pre>from pika.adapters.tornado_connection import TornadoConnection()

class PikaClient(object):
    def connect(self):
        self.connection = TornadoConnection(on_connected_callback=self.on_connected)

# Create our Tornado Application
application = tornado.web.Application([
    (r"/", ExampleHandler)
], **settings)

# Create our Pika Client
application.pika = PikaClient()

# Start the HTTPServer
http_server = tornado.httpserver.HTTPServer(application)
http_server.listen(8080)

# Get a handle to the instance of IOLoop
ioloop = tornado.ioloop.IOLoop.instance()

# Add our Pika connect to the IOLoop since we loop on ioloop.start
ioloop.add_timeout(500, application.pika.connect)

# Start the IOLoop
ioloop.start()</pre>
</div>
<span class="target" id="module-adapters.tornado_connection"></span><dl class="class">
<dt id="adapters.tornado_connection.TornadoConnection">
<em class="property">class </em><tt class="descclassname">adapters.tornado_connection.</tt><tt class="descname">TornadoConnection</tt><big>(</big><em>parameters=None</em>, <em>on_open_callback=None</em>, <em>reconnection_strategy=None</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="adapters.tornado_connection.TornadoConnection.add_backpressure_callback">
<tt class="descname">add_backpressure_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.add_backpressure_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when we think backpressue is being applied
due to the size of the output buffer being exceeded.</p>
</dd></dl>

<dl class="method">
<dt id="adapters.tornado_connection.TornadoConnection.add_on_close_callback">
<tt class="descname">add_on_close_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.add_on_close_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.tornado_connection.TornadoConnection.add_on_open_callback">
<tt class="descname">add_on_open_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.add_on_open_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has opened</p>
</dd></dl>

<dl class="method">
<dt id="adapters.tornado_connection.TornadoConnection.channel">
<tt class="descname">channel</tt><big>(</big><em>on_open_callback</em>, <em>channel_number=None</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new channel with the next available channel number or pass in
a channel number to use. Must be non-zero if you would like to specify
but it is recommended that you let Pika manage the channel numbers.</p>
</dd></dl>

<dl class="method">
<dt id="adapters.tornado_connection.TornadoConnection.close">
<tt class="descname">close</tt><big>(</big><em>code=200</em>, <em>text='Normal shutdown'</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Disconnect from RabbitMQ. If there are any open channels, it will
attempt to close them prior to fully disconnecting. Channels which
have active consumers will attempt to send a Basic.Cancel to RabbitMQ
to cleanly stop the delivery of messages prior to closing the channel.</p>
</dd></dl>

<dl class="attribute">
<dt id="adapters.tornado_connection.TornadoConnection.is_open">
<tt class="descname">is_open</tt><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.is_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean reporting the current connection state</p>
</dd></dl>

<dl class="method">
<dt id="adapters.tornado_connection.TornadoConnection.set_backpressure_multiplier">
<tt class="descname">set_backpressure_multiplier</tt><big>(</big><em>value=10</em><big>)</big><a class="headerlink" href="#adapters.tornado_connection.TornadoConnection.set_backpressure_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter the backpressure multiplier value. We set this to 10 by default.
This value is used to raise warnings and trigger the backpressure
callback.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="blockingconnection">
<span id="adapters-blocking-connection-blockingconnection"></span><h3>BlockingConnection<a class="headerlink" href="#blockingconnection" title="Permalink to this headline">¶</a></h3>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">BlockingConnection is provided for legacy and learning purposes only and it is not recommended that you use it for a production application.</p>
</div>
<p>The BlockingConnection creates a layer on top of Pika&#8217;s asynchronous core providng methods that will block until their expected response has returned.
Due to the asynchronous nature of the Basic.Deliver and Basic.Return calls from RabbitMQ to your application, you are still required to implement
continuation-passing style asynchronous methods if you&#8217;d like to receive messages from RabbitMQ using basic_consume or if you want to be notified of
a delivery failure when using basic_publish.</p>
<p>Basic.Get is a blocking call which will either return the Method Frame, Header Frame and Body of a message, or it will return a Basic.GetEmpty frame as the Method Frame.</p>
<p>For more information on using the BlockingConnection, see <a class="reference internal" href="communicating.html#blocking_connection.BlockingChannel" title="blocking_connection.BlockingChannel"><tt class="xref py py-meth docutils literal"><span class="pre">BlockingChannel</span></tt></a></p>
<p>Publishing Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Open a connection to RabbitMQ on localhost using all default parameters</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">BlockingConnection</span><span class="p">()</span>

<span class="c"># Open the channel</span>
<span class="n">channel</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">channel</span><span class="p">()</span>

<span class="c"># Declare the queue</span>
<span class="n">channel</span><span class="o">.</span><span class="n">queue_declare</span><span class="p">(</span><span class="n">queue</span><span class="o">=</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="n">durable</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">auto_delete</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="n">channel</span><span class="o">.</span><span class="n">basic_publish</span><span class="p">(</span><span class="n">exchange</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="n">body</span><span class="o">=</span><span class="s">&quot;Hello World!&quot;</span><span class="p">,</span>
                      <span class="n">properties</span><span class="o">=</span><span class="n">pika</span><span class="o">.</span><span class="n">BasicProperties</span><span class="p">(</span><span class="n">content_type</span><span class="o">=</span><span class="s">&quot;text/plain&quot;</span><span class="p">,</span> <span class="n">delivery_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Consuming Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">pika</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">from</span> <span class="nn">pika.adapters</span> <span class="kn">import</span> <span class="n">BlockingConnection</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

<span class="c"># Connect to RabbitMQ</span>
<span class="n">host</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="s">&#39;127.0.0.1&#39;</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="n">pika</span><span class="o">.</span><span class="n">ConnectionParameters</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">BlockingConnection</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>

<span class="c"># Open the channel</span>
<span class="n">channel</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">channel</span><span class="p">()</span>

<span class="c"># Declare the queue</span>
<span class="n">channel</span><span class="o">.</span><span class="n">queue_declare</span><span class="p">(</span><span class="n">queue</span><span class="o">=</span><span class="s">&quot;test&quot;</span><span class="p">,</span> <span class="n">durable</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                      <span class="n">exclusive</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">auto_delete</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c"># Start our counter at 0</span>
<span class="n">messages</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c"># Method that will receive our messages and stop consuming after 10</span>
<span class="k">def</span> <span class="nf">_on_message</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>

    <span class="k">print</span> <span class="s">&quot;Received message:&quot;</span>
    <span class="k">print</span>
    <span class="k">print</span> <span class="n">body</span>

    <span class="c"># We&#39;ve received 10 messages, stop consuming</span>
    <span class="n">messages</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">messages</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">channel</span><span class="o">.</span><span class="n">stop_consuming</span><span class="p">()</span>

 <span class="c"># This is blocking until channel.stop_consuming is called</span>
<span class="n">channel</span><span class="o">.</span><span class="n">basic_consume</span><span class="p">(</span><span class="n">_on_message</span><span class="p">,</span> <span class="n">queue</span><span class="o">=</span><span class="s">&quot;test&quot;</span><span class="p">)</span>
</pre></div>
</div>
<span class="target" id="module-adapters.blocking_connection"></span><dl class="class">
<dt id="adapters.blocking_connection.BlockingConnection">
<em class="property">class </em><tt class="descclassname">adapters.blocking_connection.</tt><tt class="descname">BlockingConnection</tt><big>(</big><em>parameters=None</em>, <em>reconnection_strategy=None</em><big>)</big><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection" title="Permalink to this definition">¶</a></dt>
<dd><p>The BlockingConnection adapter is meant for simple implementations where
you want to have blocking behavior. The behavior layered on top of the
async library. Because of the nature of AMQP there are a few callbacks
one needs to do, even in a blocking implementation. These include receiving
messages from Basic.Deliver, Basic.GetOk, and Basic.Return.</p>
<dl class="method">
<dt id="adapters.blocking_connection.BlockingConnection.add_backpressure_callback">
<tt class="descname">add_backpressure_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection.add_backpressure_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when we think backpressue is being applied
due to the size of the output buffer being exceeded.</p>
</dd></dl>

<dl class="method">
<dt id="adapters.blocking_connection.BlockingConnection.add_on_close_callback">
<tt class="descname">add_on_close_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection.add_on_close_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.blocking_connection.BlockingConnection.add_on_open_callback">
<tt class="descname">add_on_open_callback</tt><big>(</big><em>callback</em><big>)</big><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection.add_on_open_callback" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a callback notification when the connection has opened</p>
</dd></dl>

<dl class="method">
<dt id="adapters.blocking_connection.BlockingConnection.channel">
<tt class="descname">channel</tt><big>(</big><em>channel_number=None</em><big>)</big><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection.channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new channel with the next available or specified channel #</p>
</dd></dl>

<dl class="attribute">
<dt id="adapters.blocking_connection.BlockingConnection.is_open">
<tt class="descname">is_open</tt><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection.is_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean reporting the current connection state</p>
</dd></dl>

<dl class="method">
<dt id="adapters.blocking_connection.BlockingConnection.set_backpressure_multiplier">
<tt class="descname">set_backpressure_multiplier</tt><big>(</big><em>value=10</em><big>)</big><a class="headerlink" href="#adapters.blocking_connection.BlockingConnection.set_backpressure_multiplier" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter the backpressure multiplier value. We set this to 10 by default.
This value is used to raise warnings and trigger the backpressure
callback.</p>
</dd></dl>

</dd></dl>

<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>&#8220;more effective flow control mechanism that does not require cooperation from clients and reacts quickly to prevent the broker from exhausing memory - see <a class="reference external" href="http://www.rabbitmq.com/extensions.html#memsup">http://www.rabbitmq.com/extensions.html#memsup</a>&#8221; from <a class="reference external" href="http://lists.rabbitmq.com/pipermail/rabbitmq-announce/attachments/20100825/2c672695/attachment.txt">http://lists.rabbitmq.com/pipermail/rabbitmq-announce/attachments/20100825/2c672695/attachment.txt</a></td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Connecting to RabbitMQ</a><ul>
<li><a class="reference internal" href="#io-and-event-looping">IO and Event Looping</a></li>
<li><a class="reference internal" href="#continuation-passing-style">Continuation-Passing Style</a></li>
<li><a class="reference internal" href="#credentials">Credentials</a></li>
<li><a class="reference internal" href="#connection-parameters">Connection Parameters</a></li>
<li><a class="reference internal" href="#tcp-backpressure">TCP Backpressure</a></li>
<li><a class="reference internal" href="#available-adapters">Available Adapters</a><ul>
<li><a class="reference internal" href="#selectconnection">SelectConnection</a></li>
<li><a class="reference internal" href="#asyncoreconnection">AsyncoreConnection</a></li>
<li><a class="reference internal" href="#tornadoconnection">TornadoConnection</a></li>
<li><a class="reference internal" href="#blockingconnection">BlockingConnection</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Introduction to Pika</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="communicating.html"
                        title="next chapter">Communicating with RabbitMQ</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/connecting.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="communicating.html" title="Communicating with RabbitMQ"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Introduction to Pika"
             >previous</a> |</li>
        <li><a href="index.html">Pika 0.9a documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Tony Garnock-Jones, Gavin M. Roy and others.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1pre.
    </div>
  </body>
</html>