

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>adapters &mdash; Pika 0.9.1a documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.9.1a',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Pika 0.9.1a documentation" href="index.html" />
    <link rel="next" title="callback" href="callback.html" />
    <link rel="prev" title="Frequently Asked Questions" href="faq.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="callback.html" title="callback"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="faq.html" title="Frequently Asked Questions"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Pika 0.9.1a documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="adapters">
<h1>adapters<a class="headerlink" href="#adapters" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The following class level documentation is not intended for use by those using Pika in their applications. This documentation is for those who are extending Pika or otherwise working on the driver itself. For an overview of how to use adapters, please reference the <a class="reference internal" href="connecting.html"><em>Connecting to RabbitMQ</em></a> documentation.</p>
</div>
<div class="section" id="module-adapters.base_connection">
<span id="base-connection"></span><h2>base_connection<a class="headerlink" href="#module-adapters.base_connection" title="Permalink to this headline">¶</a></h2>
<p>Pika provides multiple adapters to connect to RabbitMQ:</p>
<ul class="simple">
<li><a class="reference internal" href="connecting.html#adapters-select-connection-selectconnection"><em>SelectConnection</em></a>: A native event based connection
adapter that implements select, kqueue, poll and epoll.</li>
<li><a class="reference internal" href="connecting.html#adapters-asyncore-connection-asyncoreconnection"><em>AsyncoreConnection</em></a>: Legacy adapter kept for
convenience of previous Pika users. It is recommended to use the
SelectConnection instead of AsyncoreConnection.</li>
<li><a class="reference internal" href="connecting.html#adapters-tornado-connection-tornadoconnection"><em>TornadoConnection</em></a>: Connection adapter for use
with the Tornado web framework.</li>
<li><a class="reference internal" href="connecting.html#adapters-blocking-connection-blockingconnection"><em>BlockingConnection</em></a>: Enables blocking,
synchronous operation on top of library for simple uses. This is not
recommended and is included for legacy reasons only.</li>
</ul>
<div class="section" id="baseconnection">
<h3>BaseConnection<a class="headerlink" href="#baseconnection" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.base_connection.</tt><tt class="descname">BaseConnection</tt><big>(</big><em>parameters=None</em>, <em>on_open_callback=None</em>, <em>reconnection_strategy=None</em><big>)</big></dt>
<dd><dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_adapter_connect</tt><big>(</big><em>host</em>, <em>port</em><big>)</big></dt>
<dd><p>Base connection function to be extended as needed</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_adapter_disconnect</tt><big>(</big><big>)</big></dt>
<dd><p>Called if we are forced to disconnect for some reason from Connection</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_erase_credentials</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_flush_outbound</tt><big>(</big><big>)</big></dt>
<dd><p>Call the state manager who will figure out that we need to write.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_handle_disconnect</tt><big>(</big><big>)</big></dt>
<dd><p>Called internally when we know our socket is disconnected already</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_handle_error</tt><big>(</big><em>error</em><big>)</big></dt>
<dd><p>Internal error handling method. Here we expect a <tt class="xref py py-meth docutils literal"><span class="pre">error()</span></tt> coming in
and will handle different socket errors differently.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_handle_events</tt><big>(</big><em>fd</em>, <em>events</em>, <em>error=None</em><big>)</big></dt>
<dd><p>Our IO/Event loop have called us with events, so process them</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_handle_read</tt><big>(</big><big>)</big></dt>
<dd><p>Read from the socket and call our on_data_available with the data</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_handle_write</tt><big>(</big><big>)</big></dt>
<dd><p>We only get here when we have data to write, so try and send
Pika&#8217;s suggested buffer size of data (be nice to Windows)</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">_manage_event_state</tt><big>(</big><big>)</big></dt>
<dd><p>We use this to manage the bitmask for reading/writing/error which
we want to use to have our io/event handler tell us when we can
read/write, etc</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">add_timeout</tt><big>(</big><em>delay_sec</em>, <em>callback</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BaseConnection.</tt><tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-adapters.select_connection">
<span id="select-connection"></span><h2>select_connection<a class="headerlink" href="#module-adapters.select_connection" title="Permalink to this headline">¶</a></h2>
<div class="section" id="selectconnection">
<h3>SelectConnection<a class="headerlink" href="#selectconnection" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">SelectConnection</tt><big>(</big><em>parameters=None</em>, <em>on_open_callback=None</em>, <em>reconnection_strategy=None</em><big>)</big></dt>
<dd><dl class="method">
<dt>
<tt class="descclassname">SelectConnection.</tt><tt class="descname">_adapter_connect</tt><big>(</big><em>host</em>, <em>port</em><big>)</big></dt>
<dd><p>Connect to the given host and port</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">SelectConnection.</tt><tt class="descname">_flush_outbound</tt><big>(</big><big>)</big></dt>
<dd><p>Call the state manager who will figure out that we need to write then
call the poller&#8217;s poll function to force it to process events.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ioloop">
<h3>IOLoop<a class="headerlink" href="#ioloop" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="adapters.select_connection.IOLoop">
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">IOLoop</tt><a class="headerlink" href="#adapters.select_connection.IOLoop" title="Permalink to this definition">¶</a></dt>
<dd><p>Singlton wrapper that decides which type of poller to use, creates an
instance of it in start_poller and keeps the invoking application in a
blocking state by calling the pollers start method. Poller should keep
looping until IOLoop.instance().stop() is called or there is a socket
error.</p>
<p>Also provides a convenient pass-through for add_timeout and set_events</p>
<dl class="method">
<dt id="adapters.select_connection.IOLoop.add_timeout">
<tt class="descname">add_timeout</tt><big>(</big><em>deadline</em>, <em>handler</em><big>)</big><a class="headerlink" href="#adapters.select_connection.IOLoop.add_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass through a deadline and handler to the active poller</p>
</dd></dl>

<dl class="classmethod">
<dt id="adapters.select_connection.IOLoop.instance">
<em class="property">classmethod </em><tt class="descname">instance</tt><big>(</big><em>class_</em><big>)</big><a class="headerlink" href="#adapters.select_connection.IOLoop.instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a handle to the already created object or creates a new object</p>
</dd></dl>

<dl class="attribute">
<dt id="adapters.select_connection.IOLoop.poller_type">
<tt class="descname">poller_type</tt><a class="headerlink" href="#adapters.select_connection.IOLoop.poller_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.IOLoop.remove_timeout">
<tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big><a class="headerlink" href="#adapters.select_connection.IOLoop.remove_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a timeout if it&#8217;s still in the timeout stack of our poller</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.IOLoop.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.IOLoop.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait until we have a poller</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.IOLoop.start_poller">
<tt class="descname">start_poller</tt><big>(</big><em>handler</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.IOLoop.start_poller" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the Poller, once started will take over for IOLoop.start()</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.IOLoop.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.IOLoop.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop the poller&#8217;s event loop</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.IOLoop.update_handler">
<tt class="descname">update_handler</tt><big>(</big><em>fileno</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.IOLoop.update_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass in the events we want to process</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="selectpoller">
<h3>SelectPoller<a class="headerlink" href="#selectpoller" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="adapters.select_connection.SelectPoller">
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">SelectPoller</tt><big>(</big><em>fileno</em>, <em>handler</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller" title="Permalink to this definition">¶</a></dt>
<dd><p>Default behavior is to use Select since it&#8217;s the widest supported and has
all of the methods we need for child classes as well. One should only need
to override the update_handler and start methods for additional types.</p>
<dl class="attribute">
<dt id="adapters.select_connection.SelectPoller.TIMEOUT">
<tt class="descname">TIMEOUT</tt><em class="property"> = 0.5</em><a class="headerlink" href="#adapters.select_connection.SelectPoller.TIMEOUT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectPoller.add_timeout">
<tt class="descname">add_timeout</tt><big>(</big><em>deadline</em>, <em>handler</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller.add_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a timeout to the stack by deadline</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectPoller.poll">
<tt class="descname">poll</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller.poll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectPoller.process_timeouts">
<tt class="descname">process_timeouts</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller.process_timeouts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process our self._timeouts event stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectPoller.remove_timeout">
<tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller.remove_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a timeout from the stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectPoller.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the main poller loop. It will loop here until self.closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.SelectPoller.update_handler">
<tt class="descname">update_handler</tt><big>(</big><em>fileno</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.SelectPoller.update_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Set our events to our current events</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="kqueuepoller">
<h3>KQueuePoller<a class="headerlink" href="#kqueuepoller" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="adapters.select_connection.KQueuePoller">
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">KQueuePoller</tt><big>(</big><em>fileno</em>, <em>handler</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="adapters.select_connection.KQueuePoller.TIMEOUT">
<tt class="descname">TIMEOUT</tt><em class="property"> = 0.5</em><a class="headerlink" href="#adapters.select_connection.KQueuePoller.TIMEOUT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.KQueuePoller.add_timeout">
<tt class="descname">add_timeout</tt><big>(</big><em>deadline</em>, <em>handler</em><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller.add_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a timeout to the stack by deadline</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.KQueuePoller.poll">
<tt class="descname">poll</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller.poll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.KQueuePoller.process_timeouts">
<tt class="descname">process_timeouts</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller.process_timeouts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process our self._timeouts event stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.KQueuePoller.remove_timeout">
<tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller.remove_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a timeout from the stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.KQueuePoller.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the main poller loop. It will loop here until self.closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.KQueuePoller.update_handler">
<tt class="descname">update_handler</tt><big>(</big><em>fileno</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.KQueuePoller.update_handler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="pollpoller">
<h3>PollPoller<a class="headerlink" href="#pollpoller" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="adapters.select_connection.PollPoller">
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">PollPoller</tt><big>(</big><em>fileno</em>, <em>handler</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="adapters.select_connection.PollPoller.TIMEOUT">
<tt class="descname">TIMEOUT</tt><em class="property"> = 0.5</em><a class="headerlink" href="#adapters.select_connection.PollPoller.TIMEOUT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.PollPoller.add_timeout">
<tt class="descname">add_timeout</tt><big>(</big><em>deadline</em>, <em>handler</em><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller.add_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a timeout to the stack by deadline</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.PollPoller.poll">
<tt class="descname">poll</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller.poll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.PollPoller.process_timeouts">
<tt class="descname">process_timeouts</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller.process_timeouts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process our self._timeouts event stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.PollPoller.remove_timeout">
<tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller.remove_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a timeout from the stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.PollPoller.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the main poller loop. It will loop here until self.closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.PollPoller.update_handler">
<tt class="descname">update_handler</tt><big>(</big><em>fileno</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.PollPoller.update_handler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="epollpoller">
<h3>EPollPoller<a class="headerlink" href="#epollpoller" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="adapters.select_connection.EPollPoller">
<em class="property">class </em><tt class="descclassname">adapters.select_connection.</tt><tt class="descname">EPollPoller</tt><big>(</big><em>fileno</em>, <em>handler</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller" title="Permalink to this definition">¶</a></dt>
<dd><p>EPoll and Poll function signatures match.</p>
<dl class="attribute">
<dt id="adapters.select_connection.EPollPoller.TIMEOUT">
<tt class="descname">TIMEOUT</tt><em class="property"> = 0.5</em><a class="headerlink" href="#adapters.select_connection.EPollPoller.TIMEOUT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.EPollPoller.add_timeout">
<tt class="descname">add_timeout</tt><big>(</big><em>deadline</em>, <em>handler</em><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller.add_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a timeout to the stack by deadline</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.EPollPoller.poll">
<tt class="descname">poll</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller.poll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="adapters.select_connection.EPollPoller.process_timeouts">
<tt class="descname">process_timeouts</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller.process_timeouts" title="Permalink to this definition">¶</a></dt>
<dd><p>Process our self._timeouts event stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.EPollPoller.remove_timeout">
<tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller.remove_timeout" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a timeout from the stack</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.EPollPoller.start">
<tt class="descname">start</tt><big>(</big><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Start the main poller loop. It will loop here until self.closed</p>
</dd></dl>

<dl class="method">
<dt id="adapters.select_connection.EPollPoller.update_handler">
<tt class="descname">update_handler</tt><big>(</big><em>fileno</em>, <em>events</em><big>)</big><a class="headerlink" href="#adapters.select_connection.EPollPoller.update_handler" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-adapters.asyncore_connection">
<span id="asyncore-connection"></span><h2>asyncore_connection<a class="headerlink" href="#module-adapters.asyncore_connection" title="Permalink to this headline">¶</a></h2>
<div class="section" id="asyncoreconnection">
<h3>AsyncoreConnection<a class="headerlink" href="#asyncoreconnection" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.asyncore_connection.</tt><tt class="descname">AsyncoreConnection</tt><big>(</big><em>parameters=None</em>, <em>on_open_callback=None</em>, <em>reconnection_strategy=None</em><big>)</big></dt>
<dd><dl class="method">
<dt>
<tt class="descclassname">AsyncoreConnection.</tt><tt class="descname">_adapter_connect</tt><big>(</big><em>host</em>, <em>port</em><big>)</big></dt>
<dd><p>Connect to our RabbitMQ boker using AsyncoreDispatcher, then setting
Pika&#8217;s suggested buffer size for socket reading and writing. We pass
the handle to self so that the AsyncoreDispatcher object can call back
into our various state methods.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreConnection.</tt><tt class="descname">_flush_outbound</tt><big>(</big><big>)</big></dt>
<dd><p>We really can&#8217;t flush the socket in asyncore, so instead just use this
to toggle a flag that lets it know we want to write to the socket.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="asyncoredispatcher">
<h3>AsyncoreDispatcher<a class="headerlink" href="#asyncoredispatcher" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.asyncore_connection.</tt><tt class="descname">AsyncoreDispatcher</tt><big>(</big><em>host</em>, <em>port</em><big>)</big></dt>
<dd><p>We extend <tt class="xref py py-meth docutils literal"><span class="pre">dispatcher()</span></tt> here and throw in everything we need to
handle both asyncore&#8217;s needs and pika&#8217;s. In the async adapter structure
we expect a ioloop behavior which includes timeouts and a start and stop
function.</p>
<p>Initialize the dispatcher, socket and our defaults. We turn of nageling
in the socket to allow for faster throughput.</p>
<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">_process_timeouts</tt><big>(</big><big>)</big></dt>
<dd><p>Process our self._timeouts event stack</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">add_timeout</tt><big>(</big><em>deadline</em>, <em>handler</em><big>)</big></dt>
<dd><p>Add a timeout to the stack by deadline</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">handle_close</tt><big>(</big><big>)</big></dt>
<dd><p>asyncore required method. Is called on close.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">handle_connect</tt><big>(</big><big>)</big></dt>
<dd><p>asyncore required method. Is called on connection.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">handle_read</tt><big>(</big><big>)</big></dt>
<dd><p>Read from the socket and call our on_data_available with the data</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">handle_write</tt><big>(</big><big>)</big></dt>
<dd><p>asyncore required function, is called when we can write to the socket</p>
</dd></dl>

<dl class="classmethod">
<dt>
<em class="property">classmethod </em><tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">instance</tt><big>(</big><em>class_</em><big>)</big></dt>
<dd><p>Returns a handle to the already created object or creates a new object</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">remove_timeout</tt><big>(</big><em>timeout_id</em><big>)</big></dt>
<dd><p>Remove a timeout from the stack</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">start</tt><big>(</big><big>)</big></dt>
<dd><p>Pika Adapter IOLoop start function. This blocks until we are no longer
connected.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">stop</tt><big>(</big><big>)</big></dt>
<dd><p>Pika Adapter IOLoop stop function. When called, it will close an open
connection, exiting us out of the IOLoop running in start.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">AsyncoreDispatcher.</tt><tt class="descname">writable</tt><big>(</big><big>)</big></dt>
<dd><p>asyncore required function, used to toggle the write bit on the
select poller. For some reason, if we return false while connecting
asyncore hangs, so we check for that explicitly and tell it that
it can write while it&#8217;s connecting.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-adapters.tornado_connection">
<span id="tornado-connection"></span><h2>tornado_connection<a class="headerlink" href="#module-adapters.tornado_connection" title="Permalink to this headline">¶</a></h2>
<div class="section" id="tornadoconnection">
<h3>TornadoConnection<a class="headerlink" href="#tornadoconnection" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.tornado_connection.</tt><tt class="descname">TornadoConnection</tt><big>(</big><em>parameters=None</em>, <em>on_open_callback=None</em>, <em>reconnection_strategy=None</em><big>)</big></dt>
<dd><dl class="method">
<dt>
<tt class="descclassname">TornadoConnection.</tt><tt class="descname">_adapter_connect</tt><big>(</big><em>host</em>, <em>port</em><big>)</big></dt>
<dd><p>Connect to the given host and port</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">TornadoConnection.</tt><tt class="descname">_adapter_disconnect</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-adapters.blocking_connection">
<span id="blocking-connection"></span><h2>blocking_connection<a class="headerlink" href="#module-adapters.blocking_connection" title="Permalink to this headline">¶</a></h2>
<div class="section" id="blockingconnection">
<h3>BlockingConnection<a class="headerlink" href="#blockingconnection" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.blocking_connection.</tt><tt class="descname">BlockingConnection</tt><big>(</big><em>parameters=None</em>, <em>reconnection_strategy=None</em><big>)</big></dt>
<dd><p>The BlockingConnection adapter is meant for simple implementations where
you want to have blocking behavior. The behavior layered on top of the
async library. Because of the nature of AMQP there are a few callbacks
one needs to do, even in a blocking implementation. These include receiving
messages from Basic.Deliver, Basic.GetOk, and Basic.Return.</p>
<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">_adapter_connect</tt><big>(</big><em>host</em>, <em>port</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">_flush_outbound</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">_handle_disconnect</tt><big>(</big><big>)</big></dt>
<dd><p>Called internally when we know our socket is disconnected already</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">channel</tt><big>(</big><em>channel_number=None</em><big>)</big></dt>
<dd><p>Create a new channel with the next available or specified channel #</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">close</tt><big>(</big><em>code=200</em>, <em>text='Normal shutdown'</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">disconnect</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingConnection.</tt><tt class="descname">process_data_events</tt><big>(</big><big>)</big></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="blockingchannel">
<h3>BlockingChannel<a class="headerlink" href="#blockingchannel" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.blocking_connection.</tt><tt class="descname">BlockingChannel</tt><big>(</big><em>connection</em>, <em>channel_number</em>, <em>transport=None</em><big>)</big></dt>
<dd><dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">_on_basic_deliver</tt><big>(</big><em>method_frame</em>, <em>header_frame</em>, <em>body</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">_on_basic_get</tt><big>(</big><em>caller</em>, <em>method_frame</em>, <em>header_frame</em>, <em>body</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">_on_basic_get_empty</tt><big>(</big><em>caller</em>, <em>frame</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">_on_consume_ok</tt><big>(</big><em>frame</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">_on_remote_close</tt><big>(</big><em>frame</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">_open</tt><big>(</big><em>frame</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">basic_consume</tt><big>(</big><em>consumer</em>, <em>queue=''</em>, <em>no_ack=False</em>, <em>exclusive=False</em>, <em>consumer_tag=None</em><big>)</big></dt>
<dd><p>Sends the AMQP command Basic.Consume to the broker and binds messages
for the consumer_tag to the consumer callback. If you do not pass in
a consumer_tag, one will be automatically generated for you. For
more information on basic_consume, see:</p>
<p><a class="reference external" href="http://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.consume">http://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.consume</a></p>
<p>NOTE: This blocks further execution until you call the
BlockingChannel.stop_consuming() method.</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">basic_get</tt><big>(</big><em>ticket=0</em>, <em>queue=None</em>, <em>no_ack=False</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">basic_publish</tt><big>(</big><em>exchange</em>, <em>routing_key</em>, <em>body</em>, <em>properties=None</em>, <em>mandatory=False</em>, <em>immediate=False</em><big>)</big></dt>
<dd><p>Publish to the channel with the given exchange, routing key and body.</p>
<p>If flow control is enabled and you publish a message while another is
sending, a ContentTransmissionForbidden exception ill be generated</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannel.</tt><tt class="descname">stop_consuming</tt><big>(</big><em>consumer_tag=None</em><big>)</big></dt>
<dd><p>Sends off the Basic.Cancel to let RabbitMQ know to stop consuming and
sets our internal state to exit out of the basic_consume.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="blockingchanneltransport">
<h3>BlockingChannelTransport<a class="headerlink" href="#blockingchanneltransport" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt>
<em class="property">class </em><tt class="descclassname">adapters.blocking_connection.</tt><tt class="descname">BlockingChannelTransport</tt><big>(</big><em>connection</em>, <em>channel_number</em><big>)</big></dt>
<dd><dl class="method">
<dt>
<tt class="descclassname">BlockingChannelTransport.</tt><tt class="descname">_on_rpc_complete</tt><big>(</big><em>frame</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannelTransport.</tt><tt class="descname">add_reply</tt><big>(</big><em>reply</em><big>)</big></dt>
<dd></dd></dl>

<dl class="attribute">
<dt>
<tt class="descclassname">BlockingChannelTransport.</tt><tt class="descname">no_response_frame</tt><em class="property"> = ['Basic.Ack', 'Basic.Reject', 'Basic.RecoverAsync']</em></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannelTransport.</tt><tt class="descname">remove_reply</tt><big>(</big><em>frame</em><big>)</big></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannelTransport.</tt><tt class="descname">rpc</tt><big>(</big><em>method</em>, <em>callback=None</em>, <em>acceptable_replies=</em><span class="optional">[</span><span class="optional">]</span><big>)</big></dt>
<dd><p>Shortcut wrapper to the Connection&#8217;s rpc command using its callback
stack, passing in our channel number</p>
</dd></dl>

<dl class="method">
<dt>
<tt class="descclassname">BlockingChannelTransport.</tt><tt class="descname">send_method</tt><big>(</big><em>method</em>, <em>content=None</em>, <em>wait=True</em><big>)</big></dt>
<dd><p>Shortcut wrapper to send a method through our connection, passing in
our channel number</p>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">adapters</a><ul>
<li><a class="reference internal" href="#module-adapters.base_connection">base_connection</a><ul>
<li><a class="reference internal" href="#baseconnection">BaseConnection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-adapters.select_connection">select_connection</a><ul>
<li><a class="reference internal" href="#selectconnection">SelectConnection</a></li>
<li><a class="reference internal" href="#ioloop">IOLoop</a></li>
<li><a class="reference internal" href="#selectpoller">SelectPoller</a></li>
<li><a class="reference internal" href="#kqueuepoller">KQueuePoller</a></li>
<li><a class="reference internal" href="#pollpoller">PollPoller</a></li>
<li><a class="reference internal" href="#epollpoller">EPollPoller</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-adapters.asyncore_connection">asyncore_connection</a><ul>
<li><a class="reference internal" href="#asyncoreconnection">AsyncoreConnection</a></li>
<li><a class="reference internal" href="#asyncoredispatcher">AsyncoreDispatcher</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-adapters.tornado_connection">tornado_connection</a><ul>
<li><a class="reference internal" href="#tornadoconnection">TornadoConnection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-adapters.blocking_connection">blocking_connection</a><ul>
<li><a class="reference internal" href="#blockingconnection">BlockingConnection</a></li>
<li><a class="reference internal" href="#blockingchannel">BlockingChannel</a></li>
<li><a class="reference internal" href="#blockingchanneltransport">BlockingChannelTransport</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="faq.html"
                        title="previous chapter">Frequently Asked Questions</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="callback.html"
                        title="next chapter">callback</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/adapters.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="callback.html" title="callback"
             >next</a> |</li>
        <li class="right" >
          <a href="faq.html" title="Frequently Asked Questions"
             >previous</a> |</li>
        <li><a href="index.html">Pika 0.9.1a documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Tony Garnock-Jones, Gavin M. Roy and others.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1pre.
    </div>
  </body>
</html>